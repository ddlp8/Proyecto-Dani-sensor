// Proyecto Digital - A+B+C + Display 3 dígitos (multiplexado)
// Daniela López + Ajustes de display

#include <Arduino.h>

//1) DEFINICIÓN DE PINES
#define PIN_SENSOR    34   // Entrada analógica para LM35
#define PIN_BOTON     15   // Botón (antirrebote por ISR)
#define PIN_ROJO      19   // LED rojo
#define PIN_VERDE     23   // LED verde
#define PIN_AMARILLO  21   // LED amarillo
#define PIN_SERVO     13   // Servo (LEDC)

#define canalrojo      8
#define canalverde     9
#define canalamarillo 10
#define canalservo     0
#define freqPWM       50    // 50 Hz
#define resPWM        10    // 10 bits (0..1023)

//Display 7 segmentos 
const int segmentos[] = {26, 27, 32, 33, 25, 14, 12}; // a,b,c,d,e,f,g
const int dp = 4;                                    // punto decimal
const int digitos[]  = {5, 18, 22};                   // D1(centenas), D2(decenas), D3(unidades)

//2) VARIABLES GLOBALES
volatile bool botonPresionado = false;
volatile unsigned long ultimoTiempo = 0;
const unsigned long DEBOUNCE_MS = 150;

float temperatura = 0.0f;

//Variables del display
volatile int centenas = 0;
volatile int decenas  = 0;
volatile int unidades = 0;
volatile int digitoEncendido = 0;     // 0->DECENAS, 1->UNIDADES, 2->.ALGO

// Timer para multiplexado del display
hw_timer_t *timer0 = nullptr;

//3) ISR DEL BOTÓN (ANTIRREBOTE)
void IRAM_ATTR botonISR() {
  unsigned long ahora = millis();          
  if (ahora - ultimoTiempo > DEBOUNCE_MS) {
    botonPresionado = true;
    ultimoTiempo = ahora;
  }
}

//4) INICIALIZACIÓN DE LEDS Y SERVO
void initLeds() {
  ledcSetup(canalrojo, freqPWM, resPWM);
  ledcAttachPin(PIN_ROJO, canalrojo);
  ledcWrite(canalrojo, 0);

  ledcSetup(canalverde, freqPWM, resPWM);
  ledcAttachPin(PIN_VERDE, canalverde);
  ledcWrite(canalverde, 0);

  ledcSetup(canalamarillo, freqPWM, resPWM);
  ledcAttachPin(PIN_AMARILLO, canalamarillo);
  ledcWrite(canalamarillo, 0);

  ledcSetup(canalservo, freqPWM, resPWM);
  ledcAttachPin(PIN_SERVO, canalservo);
  ledcWrite(canalservo, 128); // posición media aprox.
}

//5) SEMÁFORO + SERVO POR TEMPERATURA
void actualizarSemaforoYServo(float t) {
  if (t < 22.0f) {
    ledcWrite(canalverde, 1023);
    ledcWrite(canalamarillo, 0);
    ledcWrite(canalrojo, 0);
    ledcWrite(canalservo, 128); // ~45°
    Serial.println("Estado: VERDE, Servo ~45°");
  }
  else if (t >= 22.0f && t < 25.0f) {
    ledcWrite(canalverde, 0);
    ledcWrite(canalamarillo, 1023);
    ledcWrite(canalrojo, 0);
    ledcWrite(canalservo, 77);  // ~90°
    Serial.println("Estado: AMARILLO, Servo ~90°");
  }
  else {
    ledcWrite(canalverde, 0);
    ledcWrite(canalamarillo, 0);
    ledcWrite(canalrojo, 1023);
    ledcWrite(canalservo, 26);  // ~135°
    Serial.println("Estado: ROJO, Servo ~135°");
  }
}

//6) DISPLAY: TABLA DE DÍGITOS (activos en 1)
void printDisplay(int numero) {

  static const uint8_t numeros[10][7] = {
   //A,B,C,D,E,F,G,
    {1,1,1,1,1,1,0}, // 0
    {0,1,1,0,0,0,0}, // 1
    {1,1,0,1,1,0,1}, // 2
    {1,1,1,1,0,0,1}, // 3
    {0,1,1,0,0,1,1}, // 4
    {1,0,1,1,0,1,1}, // 5
    {1,0,1,1,1,1,1}, // 6
    {1,1,1,0,0,0,0}, // 7
    {1,1,1,1,1,1,1}, // 8
    {1,1,1,1,0,1,1}  // 9
  };
  if (numero < 0) numero = 0;
  if (numero > 9) numero = 9;

  for (int i = 0; i < 7; i++) {
    digitalWrite(segmentos[i], numeros[numero][i]);
  }
}

//7) TIMER0: ISR DE MULTIPLEXADO (1 kHz) 
void IRAM_ATTR Timer0_ISR() {
  // Apaga todos los dígitos antes de actualizar segmentos
  digitalWrite(digitos[0], LOW);
  digitalWrite(digitos[1], LOW);
  digitalWrite(digitos[2], LOW);

  if (digitoEncendido == 0) {
    // Centenas, sin punto
    digitalWrite(dp, HIGH);     
    printDisplay(centenas);
    digitalWrite(digitos[0], HIGH);
    digitoEncendido = 1;
  }
  else if (digitoEncendido == 1) {
    // Decenas, con punto decimal
    printDisplay(decenas);
    digitalWrite(dp, HIGH);       // DP encendido
    digitalWrite(digitos[1], HIGH);
    digitoEncendido = 2;
  }
  else {
    // Unidades, sin punto
    digitalWrite(dp, LOW);      // DP apagado
    printDisplay(unidades);
    digitalWrite(digitos[2], HIGH);
    digitoEncendido = 0;
  }
}

//8) INICIALIZACIÓN DE DISPLAY Y TIMER0
void initDisplayPins() {
  for (int i = 0; i < 7; i++) pinMode(segmentos[i], OUTPUT);
  pinMode(dp, OUTPUT);
  for (int i = 0; i < 3; i++) pinMode(digitos[i], OUTPUT);

  // Estado inicial: todo apagado
  for (int i = 0; i < 7; i++) digitalWrite(segmentos[i], 1);
  digitalWrite(dp, HIGH);
  for (int i = 0; i < 3; i++) digitalWrite(digitos[i], LOW);


  if (dp >= 34 && dp <= 39) {
    Serial.println("[AVISO] El pin DP está en un GPIO de solo entrada (34-39). Cambia DP a un pin de salida (p.ej. 2, 4, 16, 17, 27, 32, 33).");
  }
}

void initTimer0() {
  // Prescaler 80 -> 1 MHz (1 tick = 1 us); alarma cada 1000 us -> 1 kHz de multiplexado
  timer0 = timerBegin(0, 80, true);
  timerAttachInterrupt(timer0, &Timer0_ISR, true);
  timerAlarmWrite(timer0, 1000, true);
  timerAlarmEnable(timer0);
}

// Convierte temperatura (xx.x °C) a 3 dígitos: C-D-U con DP en el dígito de decenas
void actualizarDigitosDesdeTemperatura(float t) {
  // Mostraremos t*10 (ej. 25.6 -> 256) y colocamos DP en el dígito central.
  int v = (int)(t * 10.0f);      
  if (v < 0)   v = 0;
  if (v > 999) v = 999;

  int c = v / 100;
  int r = v - c * 100;
  int d = r / 10;
  int u = r - d * 10;

  // Escribimos de forma atómica para minimizar tearing visual
  noInterrupts();
  centenas = c;
  decenas  = d;
  unidades = u;
  interrupts();
}

//9) SETUP
void setup() {
  Serial.begin(115200);

  pinMode(PIN_SENSOR, INPUT);
  pinMode(PIN_BOTON, INPUT_PULLUP);
  attachInterrupt(PIN_BOTON, botonISR, FALLING);

  initLeds();
  initDisplayPins();
  initTimer0();

  Serial.println("Listo: presiona el botón para leer temperatura, actualizar semáforo+servo y mostrar en display.");
}

//10) LOOP PRINCIPAL
void loop() {
  if (botonPresionado) {
    botonPresionado = false;

    //Lectura LM35
    unsigned int lectura = analogRead(PIN_SENSOR);    // 0..4095
    float voltaje = lectura * (5.0f / 4095.0f);       // Tu escala actual (5 V)
    temperatura = voltaje * 100.0f;                   // LM35 -> 10 mV/°C

    //Serial debug
    Serial.print("Temperatura: ");
    Serial.print(temperatura, 1);
    Serial.println(" °C");

    //Semáforo + Servo
    actualizarSemaforoYServo(temperatura);

    //Display (C-D-U con DP en el dígito central)
    actualizarDigitosDesdeTemperatura(temperatura);
  }

  delay(1);
}
