// Proyecto Digital FINAL COMPLETO
// Daniela López Polanco 23710

// LIBRERÍAS
#include <Arduino.h>     // Librería principal de Arduino
#include "config.h"      // Archivo de configuración donde guardo credenciales y Adafruit IO

// 1) DEFINICIÓN DE PINES
#define PIN_SENSOR    34   // Entrada analógica para el sensor LM35 (temperatura)
#define PIN_BOTON     15   // Botón físico, con interrupción y antirrebote
#define PIN_ROJO      19   // LED rojo para semáforo
#define PIN_VERDE     23   // LED verde para semáforo
#define PIN_AMARILLO  21   // LED amarillo para semáforo
#define PIN_SERVO     13   // Servo controlado con PWM

// Canales PWM para cada salida
#define canalrojo      8
#define canalverde     9
#define canalamarillo 10
#define canalservo     0

// Configuración de PWM
#define freqPWM       50    // Frecuencia de 50 Hz (usada para servos)
#define resPWM        10    // Resolución de 10 bits (valores de 0 a 1023)

// Pines del display de 7 segmentos
const int segmentos[] = {26, 27, 32, 33, 25, 14, 12}; // Conexión de cada segmento (a,b,c,d,e,f,g)
const int dp = 4;                                    // Punto decimal
const int digitos[]  = {5, 18, 22};                  // Pines de control para multiplexar (centenas, decenas, unidades)

// 2) VARIABLES GLOBALES
volatile bool botonPresionado = false;   // Bandera para saber si el botón fue presionado
volatile unsigned long ultimoTiempo = 0; // Último tiempo registrado del botón
const unsigned long DEBOUNCE_MS = 150;   // Tiempo de rebote: 150 ms

// --- ADAFRUIT IO ---
#define IO_LOOP_DELAY 5000   // Intervalo de envío de datos: cada 5 segundos
unsigned long lastUpdate = 0; // Controla la última vez que se publicó un dato

// Feeds de Adafruit IO
AdafruitIO_Feed *canaltemperatura = io.feed("temperatura"); // Feed donde envío la temperatura
AdafruitIO_Feed *canalcontrol = io.feed("control");         // Feed opcional para recibir comandos

float temperatura = 0.0f; // Variable que guarda la temperatura leída

// Variables del display
volatile int centenas = 0;
volatile int decenas  = 0;
volatile int unidades = 0;
volatile int digitoEncendido = 0; // Controla qué dígito está encendido en cada instante

// Timer para multiplexado del display
hw_timer_t *timer0 = nullptr;

// 3) ISR DEL BOTÓN (ANTIRREBOTE)
// Se activa cuando se presiona el botón físico
void IRAM_ATTR botonISR() {
  unsigned long ahora = millis();          
  // Verifico que pasaron más de 150 ms para evitar rebotes eléctricos
  if (ahora - ultimoTiempo > DEBOUNCE_MS) {
    botonPresionado = true;   // Marco que el botón fue presionado
    ultimoTiempo = ahora;     // Actualizo el tiempo
  }
}

// 4) INICIALIZACIÓN DE LEDS Y SERVO
// Configuro PWM para cada LED y para el servo
void initLeds() {
  // LED rojo
  ledcSetup(canalrojo, freqPWM, resPWM);
  ledcAttachPin(PIN_ROJO, canalrojo);
  ledcWrite(canalrojo, 0);

  // LED verde
  ledcSetup(canalverde, freqPWM, resPWM);
  ledcAttachPin(PIN_VERDE, canalverde);
  ledcWrite(canalverde, 0);

  // LED amarillo
  ledcSetup(canalamarillo, freqPWM, resPWM);
  ledcAttachPin(PIN_AMARILLO, canalamarillo);
  ledcWrite(canalamarillo, 0);

  // Servo
  ledcSetup(canalservo, freqPWM, resPWM);
  ledcAttachPin(PIN_SERVO, canalservo);
  ledcWrite(canalservo, 128); // Inicio en posición media aprox.
}

// 5) SEMÁFORO + SERVO POR TEMPERATURA
// Dependiendo de la temperatura, se enciende un LED del semáforo y se mueve el servo
void actualizarSemaforoYServo(float t) {
  if (t < 22.0f) { // Temperatura baja
    ledcWrite(canalverde, 1023);   // Enciendo LED verde
    ledcWrite(canalamarillo, 0);
    ledcWrite(canalrojo, 0);
    ledcWrite(canalservo, 128);    // Servo ~45°
    Serial.println("Estado: VERDE, Servo ~45°");
  }
  else if (t >= 22.0f && t < 25.0f) { // Temperatura intermedia
    ledcWrite(canalverde, 0);
    ledcWrite(canalamarillo, 1023);   // Enciendo LED amarillo
    ledcWrite(canalrojo, 0);
    ledcWrite(canalservo, 77);        // Servo ~90°
    Serial.println("Estado: AMARILLO, Servo ~90°");
  }
  else { // Temperatura alta
    ledcWrite(canalverde, 0);
    ledcWrite(canalamarillo, 0);
    ledcWrite(canalrojo, 1023);       // Enciendo LED rojo
    ledcWrite(canalservo, 26);        // Servo ~135°
    Serial.println("Estado: ROJO, Servo ~135°");
  }
}

// 6) DISPLAY: TABLA DE DÍGITOS (activos en 1)
// Tabla que define qué segmentos se encienden para mostrar cada número
void printDisplay(int numero) {
  static const uint8_t numeros[10][7] = {
   //A,B,C,D,E,F,G
    {1,1,1,1,1,1,0}, // 0
    {0,1,1,0,0,0,0}, // 1
    {1,1,0,1,1,0,1}, // 2
    {1,1,1,1,0,0,1}, // 3
    {0,1,1,0,0,1,1}, // 4
    {1,0,1,1,0,1,1}, // 5
    {1,0,1,1,1,1,1}, // 6
    {1,1,1,0,0,0,0}, // 7
    {1,1,1,1,1,1,1}, // 8
    {1,1,1,1,0,1,1}  // 9
  };
  // Seguridad: si el número es inválido lo corrijo
  if (numero < 0) numero = 0;
  if (numero > 9) numero = 9;

  // Activo segmentos correspondientes al número
  for (int i = 0; i < 7; i++) {
    digitalWrite(segmentos[i], numeros[numero][i]);
  }
}

// 7) TIMER0: ISR DE MULTIPLEXADO (1 kHz)
// Controla el display multiplexado encendiendo un dígito por vez muy rápido
void IRAM_ATTR Timer0_ISR() {
  // Apago todos los dígitos antes de actualizar
  digitalWrite(digitos[0], LOW);
  digitalWrite(digitos[1], LOW);
  digitalWrite(digitos[2], LOW);

  if (digitoEncendido == 0) {
    // Muestro centenas
    digitalWrite(dp, HIGH);     
    printDisplay(centenas);
    digitalWrite(digitos[0], HIGH);
    digitoEncendido = 1;
  }
  else if (digitoEncendido == 1) {
    // Muestro decenas (con punto decimal)
    printDisplay(decenas);
    digitalWrite(dp, HIGH);      
    digitalWrite(digitos[1], HIGH);
    digitoEncendido = 2;
  }
  else {
    // Muestro unidades
    digitalWrite(dp, LOW);      
    printDisplay(unidades);
    digitalWrite(digitos[2], HIGH);
    digitoEncendido = 0;
  }
}

// 8) INICIALIZACIÓN DE DISPLAY Y TIMER0
void initDisplayPins() {
  // Configuro pines de segmentos y dígitos como salidas
  for (int i = 0; i < 7; i++) pinMode(segmentos[i], OUTPUT);
  pinMode(dp, OUTPUT);
  for (int i = 0; i < 3; i++) pinMode(digitos[i], OUTPUT);

  // Inicializo todo apagado
  for (int i = 0; i < 7; i++) digitalWrite(segmentos[i], 1);
  digitalWrite(dp, HIGH);
  for (int i = 0; i < 3; i++) digitalWrite(digitos[i], LOW);

  // Aviso si usé un pin de solo entrada para DP (error común en ESP32)
  if (dp >= 34 && dp <= 39) {
    Serial.println("[AVISO] El pin DP está en un GPIO de solo entrada. Cambiar a otro pin.");
  }
}

void initTimer0() {
  // Configuro Timer0 con prescaler para que cuente en microsegundos
  timer0 = timerBegin(0, 80, true);       
  timerAttachInterrupt(timer0, &Timer0_ISR, true);
  timerAlarmWrite(timer0, 1000, true);    // Interrupción cada 1 ms -> 1 kHz
  timerAlarmEnable(timer0);
}

// Convierte temperatura a 3 dígitos (centenas, decenas, unidades)
// Ej: 23.5 °C -> se muestra 2 (centenas), 3 (decenas) y 5 (unidades)
void actualizarDigitosDesdeTemperatura(float t) {
  int v = (int)(t * 10.0f);      
  if (v < 0)   v = 0;
  if (v > 999) v = 999;

  int c = v / 100;
  int r = v - c * 100;
  int d = r / 10;
  int u = r - d * 10;

  noInterrupts();   // Protejo variables usadas en ISR
  centenas = c;
  decenas  = d;
  unidades = u;
  interrupts();
}

// --- CALLBACK de ADAFRUIT IO ---
// Función que se ejecuta cuando se recibe un mensaje desde el feed "control"
void handleMessage(AdafruitIO_Data *data) {
  Serial.print("Recibido desde Adafruit IO: ");
  Serial.println(data->value());

  // Control remoto de LEDs desde Adafruit IO
  if (strcmp(data->value(), "rojo") == 0) {
    ledcWrite(canalrojo, 1023);
    ledcWrite(canalverde, 0);
    ledcWrite(canalamarillo, 0);
  }
  if (strcmp(data->value(), "verde") == 0) {
    ledcWrite(canalverde, 1023);
    ledcWrite(canalrojo, 0);
    ledcWrite(canalamarillo, 0);
  }
}

// 9) SETUP
void setup() {
  Serial.begin(115200);

  // Configuración de pines
  pinMode(PIN_SENSOR, INPUT);
  pinMode(PIN_BOTON, INPUT_PULLUP);
  attachInterrupt(PIN_BOTON, botonISR, FALLING); // ISR en botón

  initLeds();       // Inicializo LEDs y servo
  initDisplayPins();// Inicializo display
  initTimer0();     // Inicializo timer para multiplexado

  // --- INICIO DE ADAFRUIT IO ---
  Serial.print("Conectando a Adafruit IO");
  io.connect();   // Inicio conexión a la nube

  // Me suscribo al feed "control" para poder recibir comandos
  canalcontrol->onMessage(handleMessage);

  // Espero conexión
  while(io.status() < AIO_CONNECTED) {
    Serial.print(".");
    delay(500);
  }
  Serial.println(" Conectado!");
  Serial.println(io.statusText());

  Serial.println("Listo: presiona el botón para leer temperatura, actualizar semáforo+servo, mostrar en display y enviar a Adafruit IO.");
}

// 10) LOOP PRINCIPAL
void loop() {
  io.run();   // Importante: mantiene la conexión con Adafruit IO activa

  if (botonPresionado) {
    botonPresionado = false;

    // Lectura del LM35
    unsigned int lectura = analogRead(PIN_SENSOR);    // Valor crudo 0..4095
    float voltaje = lectura * (5.0f / 4095.0f);       // Escalo a voltaje real
    temperatura = voltaje * 100.0f;                   // LM35: 10 mV por °C

    // Debug en Serial
    Serial.print("Temperatura: ");
    Serial.print(temperatura, 1);
    Serial.println(" °C");

    // Actualizo semáforo y servo según temperatura
    actualizarSemaforoYServo(temperatura);

    // Actualizo display
    actualizarDigitosDesdeTemperatura(temperatura);
  }

  // --- PUBLICACIÓN periódica de temperatura ---
  if (millis() > (lastUpdate + IO_LOOP_DELAY)) {
    Serial.print("Enviando temperatura -> ");
    Serial.println(temperatura);
    canaltemperatura->save(temperatura); // Mando dato a Adafruit IO
    lastUpdate = millis();
  }

  delay(1); // Pequeña espera para no saturar el loop
}
